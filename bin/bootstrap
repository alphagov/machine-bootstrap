#!/usr/bin/env python
"""
Title:
License: MIT

Description:

    This script presumes that you have a user with passwordless sudo access and
    you wish to change the password of that user and apply the puppet manifest
    in the puppet directory to that machine. To avoid password prompting
    and ever putting the clear-text password on the new VM, the mechanism of
    changing is to generate an Ubuntu shadow file entry and place it into the
    /etc/shadow file via SSH.

    Given only an IP address, the script will assume that it is connecting as
    `ubuntu` with password `ubuntu` on port 22 and will change the password to
    a random alphanumeric string of length 12 chars. All of these defaults are
    optional.

    It will then connect to the machine with the new password and perform any
    configuration via puppet.

Usage:

    bootstrap -h

"""

# Standard python libraries
import argparse
import crypt
import getpass
import logging
import random
import string
import sys
from Crypto.PublicKey import RSA
from contextlib import closing
# Non-standard python libraries
import paramiko
import scpclient
from passlib.hash import sha512_crypt

# Argument parsing
parser = argparse.ArgumentParser(description='Bootstraps a default Ubuntu VM using SSH and Puppet')
parser.add_argument('ip',help="IP of machine to connect to")
parser.add_argument('-C','--change-password-only',dest='password_only',action='store_true',default=False,help="Change password, but do not attempt to run puppet on the machine [False]")
parser.add_argument('-d',dest='debug',action='store_true',default=False,help="Show debug output")
parser.add_argument('-H','--harden-only',dest='harden_only',action='store_true',default=False,help="Do not change the password, simply run Puppet to harden the machine [False]")
parser.add_argument('-k',dest='authorized_key',type=str,default="NONE",help="Supply an authorized_keys entry for this user (quoted exact line format from .ssh/authorized_keys)")
parser.add_argument('-l',dest='length',type=int,default=12,help="Length of auto-generated password [12]")
parser.add_argument('-p',dest='prompt',action='store_true',default=False,help="Prompt for password [otherwise assume it is 'ubuntu']")
parser.add_argument('-P',dest='port',type=int,default=22,help="Port to connect to [22]")
parser.add_argument('-s',dest='bootstrap_script',type=str,default="",help="Path to optional script to run after puppet configuration")
parser.add_argument('-u',dest='username',default='ubuntu',help="Username to connect as [ubuntu]")
config = parser.parse_args()
if config.prompt:
    config.password = getpass.getpass('Password for %s@%s: ' % (config.username,config.ip))
else:
    config.password = 'ubuntu'
# End argument parsing

log = logging.getLogger(__name__)

# General helper functions
def throw_error(string,exitcode):
    """Print a message and exit with a status code"""
    log.error ("%s, try again with debug mode on (-d)" % string)
    sys.exit(exitcode)
# End helper functions

# Password generation and Encryption
def choose_random_chars(alphabet,length):
    """From an alphabet, choose a number of random characters"""
    chars = []
    for i in range(length):
        chars.append(random.choice(alphabet))
    return "".join(chars)

def generate_salt(length):
    """Generate a random string of length to be used as a SHAS512 salt"""
    salt_alphabet = string.digits + string.ascii_letters + "./"
    salt = choose_random_chars(salt_alphabet,length)
    log.debug("... ... SALT %s" % salt)
    return salt

def generate_password(length):
    """Generate a random string of length to be used as a password"""
    password_alphabet = string.digits + string.ascii_letters
    password = choose_random_chars(password_alphabet,length)
    log.debug("... ... PASSWORD %s" % password)
    return password

def encrypt_password(password):
    """Generate the salted password hash using SHA512 with the same options as Ubuntu 12.04"""
    return sha512_crypt.encrypt(password,salt=generate_salt(8),rounds=5000)

def new_password(user):
    """Output {password => "PLAINTEXT", shadow => "Shadow entry"} dict for later use"""
    log.debug("... Generating password")
    output = {}
    output['password'] = generate_password(config.length)
    output['shadow'] = "%s:%s:::::::" % (user, encrypt_password(output['password']))
    log.debug("... ... SHADOW %s " % output['shadow'])
    return output
# End password generation and encryption

# SSH connections
def ssh_connect(password=config.password):
    """Connect to config.ip as config.username on config.port with a password (defaults to config.password)"""
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    log.debug('... Connecting to %s on port %s with %s:%s' % (config.ip,config.port,config.username,password))
    try:
        ssh.connect(config.ip,username=config.username,password=password,port=config.port)
    except:
        throw_error("Could not connect to machine",1)
    return ssh

def ssh_runcommand(session,command):
    """Given an SSH session, run a command and if debug mode is enabled, show the output"""
    try:
        log.debug('Running command: %s' % command)
        stdin, stdout, stderr = session.exec_command(command)
    except:
        throw_error("Command failed - %s" % command,2)
    for line in stdout.readlines():
            log.debug('stdout: %s' % line.rstrip())
    for line in stderr.readlines():
            log.debug('stderr: %s' % line.rstrip())

def ssh_changepassword(user):
    """SSH to to a machine, try to change the password and test for success"""
    passwd = new_password(user)
    command = "sudo sed -i 's;" + user + ":.*;" + passwd['shadow'] + ";g' /etc/shadow"
    ssh_runcommand(ssh_connect(),command)
    try:
        log.debug("... Testing new password")
        ssh_runcommand(ssh_connect(passwd['password']),'uname -a')
        return passwd['password']
    except:
        throw_error("Could not connect to machine after password change",3)

def ssh_copydir(session,sourcedir,destdir):
    with closing(scpclient.WriteDir(session.get_transport(), destdir)) as scp:
        scp.send_dir(sourcedir, preserve_times=True)

def ssh_copyfile(session,sourcefile,destdir):
    with closing(scpclient.Write(session.get_transport(),destdir)) as scp:
        scp.send_file(sourcefile, preserve_times=True)

# End SSH connections

# RSA Key Generation
def generate_rsa_key():
    log.info("Creating new SSH key for this machine")
    key = RSA.generate(2048)
    private_key = key.exportKey('PEM')
    public_key = key.exportKey('OpenSSH') + " %s@%s" % (config.username,config.ip)
    log.info("... New SSH public key (do not need to save)")
    print ""
    print public_key
    print
    log.info("... New SSH private key (please save to a file)")
    print ""
    print private_key
    print ""
    return public_key

def setup_key_auth(password,key):
    log.info("Setting up key-based auth for %s" % config.username)
    session = ssh_connect(password)
    ssh_runcommand(session,'test -d ~%s/.ssh || mkdir ~%s/.ssh && chmod 700 ~%s/.ssh' % (config.username,config.username,config.username))
    ssh_runcommand(session,'echo "%s" > ~%s/.ssh/authorized_keys && chmod 600 ~%s/.ssh/authorized_keys' % (key,config.username,config.username))

# end RSA key generation

# Machine configuration related tasks
def configure_machine(password,bootstrap_script=""):
    log.info("Copying up the puppet directory")
    session = ssh_connect(password)
    # Copy the puppet dir from this repo
    ssh_copydir(session,'./puppet','/tmp/')
    log.info("Removing old puppet package")
    # Puppet package is 2.7.11, we need >2.7.13 so remove it
    ssh_runcommand(session,'sudo apt-get -y remove puppet puppet-common facter')
    log.info("Installing puppet from Gems")
    # Install a good version of Puppet
    ssh_runcommand(session,'sudo gem install --no-rdoc --no-ri --version "3.1.1" puppet ')
    ssh_runcommand(session,'sudo gem install --no-rdoc --no-ri --version "0.9.9" librarian-puppet')
    ssh_runcommand(session,'sudo gem install --no-rdoc --no-ri --version "1.7.1" facter')
    # Download our included puppet modules
    log.info("Running librarian-puppet")
    ssh_runcommand(session,'cd /tmp/puppet; sudo librarian-puppet install')
    # Run puppet
    log.info("Applying puppet config")
    ssh_runcommand(session,'sudo puppet apply --modulepath=/tmp/puppet/vendor/modules /tmp/puppet/manifests/site.pp')
    if bootstrap_script != "":
        log.info("Running optional bootstrap script - %s" % bootstrap_script)
        ssh_copyfile(session,bootstrap_script,'~/provisioner.script')
        ssh_runcommand(session,'chmod 755 ~/provisioner.script')
        ssh_runcommand(session,'sudo ~/provisioner.script')
        log.info("Optional bootstrap script complete")

# End machine configuration related tasks

def main():
    _log_level = logging.INFO
    if config.debug:
        _log_level = logging.DEBUG
    logging.basicConfig(format='%(levelname)s: %(message)s', level=_log_level)
    if config.harden_only and config.password_only:
        throw_error("-H and -C are mutually exclusive. If you want to change the password and harden the machine, remove both options",254)

    password = ""
    if not config.harden_only:
        password = ssh_changepassword(config.username)
        log.info("Password for %s@%s is now %s" % (config.username,config.ip,password))

    if not config.password_only:
        # If we changed the password, use the new one
        if password == "":
            new_password = config.password
        else:
            new_password = password

        # If we have been passed an authorized_keys entry, then use it.
        if config.authorized_key == "NONE":
            key = generate_rsa_key()
        else:
            key = config.authorized_key
        setup_key_auth(new_password,key)
        configure_machine(new_password,config.bootstrap_script)
    log.info("Bootstrap script exiting successfully")
    sys.exit(0)

if __name__ == "__main__":
    main()
