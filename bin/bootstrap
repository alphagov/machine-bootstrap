#!/usr/bin/env python
"""
Title: machine-bootstrap
License: MIT

Description:

    This script presumes that you have a user with passwordless sudo access and
    you wish to change the password of that user and apply the puppet manifest
    in the puppet directory to that machine. To avoid password prompting
    and ever putting the clear-text password on the new VM, the mechanism of
    changing is to generate an Ubuntu shadow file entry and place it into the
    /etc/shadow file via SSH.

    Given only an IP address, the script will assume that it is connecting as
    `ubuntu` with password `ubuntu` on port 22 and will change the password to
    a random alphanumeric string of length 12 chars. All of these defaults are
    optional.

    It will then connect to the machine with the new password and perform any
    configuration via puppet.

    NB: If you are using this script to generate GPG keys you should be aware that
    in order to generate enough entropy in a VM, we are installing haveged - that
    means that the entropy quality won't be quite as good as when GPG solely uses
    /dev/random. If you have concerns about attack via this kind of thing you
    probably should generate your GPG keys on a machine with more natural entropy.
    Read more about haveged at http://www.issihosts.com/haveged/

Usage:

    bootstrap -h

"""

# Standard python libraries
import argparse
import crypt
import getpass
import logging
import random
import re
import string
import sys
from Crypto.PublicKey import RSA
from contextlib import closing
# Non-standard python libraries
import paramiko
import scpclient
from passlib.hash import sha512_crypt

# Argument parsing
def parse_config():
    parser = argparse.ArgumentParser(description='Bootstraps a default Ubuntu VM using SSH and Puppet')
    parser.add_argument('ip',help="IP of machine to connect to")
    parser.add_argument('-C','--change-password-only',dest='password_only',action='store_true',default=False,help="Change password, but do not attempt to run puppet on the machine [False]")
    parser.add_argument('-d',dest='debug',action='store_true',default=False,help="Show debug output")
    parser.add_argument('-G',dest='hiera_gpg_email',type=str,default=None,help="Email for root GPG key. Sets GPG for root with the name above and this email.")
    parser.add_argument('-H','--harden-only',dest='harden_only',action='store_true',default=False,help="Do not change the password, simply run Puppet to harden the machine [False]")
    parser.add_argument('-k',dest='authorized_key',type=str,default=None,help="Supply an authorized_keys entry for this user (quoted exact line format from .ssh/authorized_keys)")
    parser.add_argument('-l',dest='length',type=int,default=12,help="Length of auto-generated password [12]")
    parser.add_argument('-N',dest='hiera_gpg_name',type=str,default='Puppet Hiera Key',help="Name for root GPG key. [Puppet Hiera Key]")
    parser.add_argument('-p',dest='prompt',action='store_true',default=False,help="Prompt for password [otherwise assume it is 'ubuntu']")
    parser.add_argument('-P',dest='port',type=int,default=22,help="Port to connect to [22]")
    parser.add_argument('-s',dest='bootstrap_script',type=str,default=None,help="Path to optional script to run after puppet configuration")
    parser.add_argument('-u',dest='username',default='ubuntu',help="Username to connect as [ubuntu]")
    parser.add_argument('-v',dest='verbose',action='store_true',default=False,help="Show verbose output")
    config = parser.parse_args()
    if config.prompt:
        config.password = getpass.getpass('Password for %s@%s: ' % (config.username,config.ip))
    else:
        config.password = 'ubuntu'
    return config
# End argument parsing

log = logging.getLogger(__name__)

# General helper functions
def throw_error(string,exitcode):
    """Print a message and exit with a status code"""
    log.error ("%s, try again with debug mode on (-d)" % string)
    sys.exit(exitcode)
# End helper functions

# Password generation and Encryption
def choose_random_chars(alphabet,length):
    """From an alphabet, choose a number of random characters"""
    chars = []
    for i in range(length):
        chars.append(random.choice(alphabet))
    return "".join(chars)

def generate_salt(length):
    """Generate a random string of length to be used as a SHAS512 salt"""
    salt_alphabet = string.digits + string.ascii_letters + "./"
    salt = choose_random_chars(salt_alphabet,length)
    log.debug("... ... SALT %s" % salt)
    return salt

def generate_password(length):
    """Generate a random string of length to be used as a password"""
    password_alphabet = string.digits + string.ascii_letters
    password = choose_random_chars(password_alphabet,length)
    log.debug("... ... PASSWORD %s" % password)
    return password

def encrypt_password(password):
    """Generate the salted password hash using SHA512 with the same options as Ubuntu 12.04"""
    return sha512_crypt.encrypt(password,salt=generate_salt(8),rounds=5000)

def new_password(length, user):
    """Output {password => "PLAINTEXT", shadow => "Shadow entry"} dict for later use"""
    log.debug("... Generating password")
    output = {}
    output['password'] = generate_password(length)
    output['shadow'] = "%s:%s:::::::" % (user, encrypt_password(output['password']))
    log.debug("... ... SHADOW %s " % output['shadow'])
    return output
# End password generation and encryption

# SSH connections
def ssh_connect(username, password, ip, port):
    """Connect to ip as username on port with password"""
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    log.debug('... Connecting to %s on port %s with %s:%s' % (ip,port,username,password))
    try:
        ssh.connect(username=username,password=password,hostname=ip,port=port)
    except:
        throw_error("Could not connect to machine",1)
    return ssh


def ssh_runcommand(session,command,show_output=False):
    """Given an SSH session, run a command and if debug mode is enabled, show the output"""
    try:
        log.debug('Running command: %s' % command)
        stdin, stdout, stderr = session.exec_command(command)
    except:
        throw_error("Command failed - %s" % command,2)
    for line in stderr.readlines():
            log.debug('stderr: %s' % line.rstrip())
    if show_output:
        return stdout
    else:
        for line in stdout.readlines():
            log.debug('stdout: %s' % line.rstrip())

def ssh_checksudo(session):
    """Given an SSH session, check if the sudo command works without a password"""
    try:
        log.debug('Checking for sudo without a password')
        stdin, stdout, stderr = session.exec_command('sudo -n id')
    except:
        throw_error('Cannot check whether sudo works',3)
    regex = re.compile('.*password is required.*')
    for line in stderr.readlines():
        log.debug(stderr)
        if re.match(regex,line):
            throw_error('Sudo requires a password, bootstrapping would fail!',4)


def ssh_changepassword(length, user, current_password, ip, port):
    """SSH to to a machine, try to change the password and test for success"""
    passwd = new_password(length=length, user=user)
    command = "sudo sed -i 's;" + user + ":.*;" + passwd['shadow'] + ";g' /etc/shadow"
    with closing(ssh_connect(username=user,password=current_password,ip=ip,port=port)) as session:
        ssh_runcommand(session,command)
    try:
        log.debug("... Testing new password")
        with closing(ssh_connect(username=user,password=passwd['password'],ip=ip,port=port)) as session:
            ssh_runcommand(session,'uname -a')
        return passwd['password']
    except:
        throw_error("Could not connect to machine after password change",3)

def ssh_copydir(session,sourcedir,destdir):
    with closing(scpclient.WriteDir(session.get_transport(), destdir)) as scp:
        scp.send_dir(sourcedir, preserve_times=True)

def ssh_copyfile(session,sourcefile,destdir):
    with closing(scpclient.Write(session.get_transport(),destdir)) as scp:
        scp.send_file(sourcefile, preserve_times=True)

# End SSH connections

# RSA Key Generation
def generate_rsa_key(username, ip):
    log.info("Creating new SSH key for this machine")
    key = RSA.generate(2048)
    private_key = key.exportKey('PEM')
    public_key = key.exportKey('OpenSSH') + " %s@%s" % (username,ip)
    log.warning("... New SSH public key (do not need to save)")
    print ""
    print public_key
    print
    log.warning("... New SSH private key (please save to a file)")
    print ""
    print private_key
    print ""
    return public_key

def setup_key_auth(session,username,key):
    log.info("Setting up key-based auth for %s" % username)
    ssh_runcommand(session,'test -d ~%s/.ssh || mkdir ~%s/.ssh && chmod 700 ~%s/.ssh' % (username,username,username))
    ssh_runcommand(session,'echo "%s" > ~%s/.ssh/authorized_keys && chmod 600 ~%s/.ssh/authorized_keys' % (key,username,username))

# end RSA key generation

# Machine configuration related tasks
def configure_machine(session,bootstrap_script,hiera_gpg_email,hiera_gpg_name):
    log.info("Copying up the puppet directory")
    # Copy the puppet dir from this repo
    ssh_copydir(session,'./puppet','/tmp/')
    ssh_copydir(session,'./puppet/manifests','/tmp/puppet')
    log.info("Removing old puppet package")
    # Install Ruby1.9.1 if missing.
    ssh_runcommand(session,'[[ $(dpkg -s ruby1.9.1 >/dev/null 2>&1) ]] || sudo apt-get install -qq ruby1.9.1 2>&1' )
    ssh_runcommand(session,'[[ $(dpkg -s ruby1.9.1-dev >/dev/null 2>&1) ]] || sudo apt-get install -qq ruby1.9.1-dev 2>&1' )
    # Puppet package is 2.7.11, we need >2.7.13 so remove it
    ssh_runcommand(session,'sudo apt-get -y remove puppet puppet-common facter')
    log.info("Installing puppet from Gems")
    # Install a good version of Puppet
    ssh_runcommand(session,'sudo gem which puppet || sudo gem install --no-rdoc --no-ri --version "3.1.1" puppet ')
    ssh_runcommand(session,'sudo gem list | grep librarian-puppet || sudo gem install --no-rdoc --no-ri --version "0.9.9" librarian-puppet')
    ssh_runcommand(session,'sudo gem which facter || sudo gem install --no-rdoc --no-ri --version "1.7.1" facter')
    # Download our included puppet modules
    log.info("Running librarian-puppet")
    ssh_runcommand(session,'cd /tmp/puppet; sudo librarian-puppet install')
    # Run puppet
    log.info("Applying puppet config")
    ssh_runcommand(session,'sudo puppet apply --modulepath=/tmp/puppet/modules /tmp/puppet/manifests/site.pp')
    if bootstrap_script:
        log.info("Running optional bootstrap script - %s" % bootstrap_script)
        ssh_copyfile(session,bootstrap_script,'~/provisioner.script')
        ssh_runcommand(session,'chmod 755 ~/provisioner.script')
        ssh_runcommand(session,'sudo ~/provisioner.script')
        log.info("Optional bootstrap script complete")
    #
    # This will create a GPG key for root with the email address specified in the
    # -G argument with a name which defaults to 'Puppet Hiera Key'. It's intended
    # to be used to encrypt files as part of a hiera-gpg setup
    #
    if hiera_gpg_email:
        log.warning("Creating GPG for root with name '%s' and email '%s'" % (hiera_gpg_name,hiera_gpg_email))
        log.warning('NB: Installing haveged to help with entropy - this weakens your system slightly. Please read the notes at the beginning of this script')
        log.debug('Installing gnupg2 and haveged')
        ssh_runcommand(session,'sudo apt-get install -y gnupg2 haveged')
        log.debug('Creating /tmp/gnupg_opts')
        ssh_runcommand(session,'echo "Key-Type: RSA" > /tmp/gnupg_opts')
        ssh_runcommand(session,'echo "Key-Length: 4096" >> /tmp/gnupg_opts')
        ssh_runcommand(session,'echo "Subkey-Type: default" >> /tmp/gnupg_opts')
        ssh_runcommand(session,'echo "Name-Real: %s" >> /tmp/gnupg_opts' % hiera_gpg_name)
        ssh_runcommand(session,'echo "Name-Email: %s" >> /tmp/gnupg_opts' % hiera_gpg_email)
        ssh_runcommand(session,'echo "Expire-Date: 0" >> /tmp/gnupg_opts')
        ssh_runcommand(session,'echo "%commit" >> /tmp/gnupg_opts')
        log.debug('Creating GPG key')
        ssh_runcommand(session,'sudo su - root /bin/sh -c "cat /tmp/gnupg_opts | gpg2 --batch --gen-key -"')
        log.warning('Exporting GPG key for root - you may need to import this into your Hiera-GPG setup')
        key = ssh_runcommand(session,'sudo su - root /bin/sh -c "gpg2 --armor --export \"%s\""' % hiera_gpg_name,show_output=True)
        print
        for line in key.readlines():
            print line.rstrip()
        print
# End machine configuration related tasks

def main():
    config = parse_config()
    _log_level = logging.WARNING
    if config.verbose:
        _log_level = logging.INFO
    if config.debug:
        _log_level = logging.DEBUG
    logging.basicConfig(format='%(levelname)s: %(message)s', level=_log_level)
    if config.harden_only and config.password_only:
        throw_error("-H and -C are mutually exclusive. If you want to change the password and harden the machine, remove both options",254)

    password = ""
    machine = {'ip':config.ip, 'port':config.port}

    ssh_checksudo(ssh_connect(config.username, config.password, config.ip, config.port))

    if not config.harden_only:
        password = ssh_changepassword(user=config.username,current_password=config.password,length=config.length,**machine)
        log.warning("Password for %s@%s is now %s" % (config.username,config.ip,password))

    if not config.password_only:
        # If we changed the password, use the new one
        if password == "":
            new_password = config.password
        else:
            new_password = password

        # If we have been passed an authorized_keys entry, then use it.
        if config.authorized_key:
            key = config.authorized_key
        else:
            key = generate_rsa_key(username=config.username,ip=config.ip)
        with closing(ssh_connect(username=config.username,password=new_password,ip=config.ip,port=config.port)) as session:
            log.warning("Setting up key-based auth")
            setup_key_auth(session,username=config.username,key=key)
            log.warning("Configuring machine")
            configure_machine(session,bootstrap_script=config.bootstrap_script,hiera_gpg_email=config.hiera_gpg_email,hiera_gpg_name=config.hiera_gpg_name)
    log.warning("Bootstrap script exiting successfully")
    sys.exit(0)


if __name__ == "__main__":
    main()
